{"version":3,"file":"static/js/864.597e902d.chunk.js","mappings":"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","sources":["../../ui/src/components/CodeMirror.tsx","../../ui/src/components/PageHeader.tsx","../../ui/src/components/Tabs.tsx","../../ui/src/components/configeditor/codemirror-yaml/mode.tsx"],"sourcesContent":["import 'codemirror/lib/codemirror.css';\n\nimport * as React from 'react';\nimport {Controlled, UnControlled as Uncontrolled} from 'react-codemirror2';\nimport {createGlobalStyle} from 'styled-components/macro';\n\nimport {Colors} from './Colors';\nimport {Icons} from './Icon';\nimport {registerYaml} from './configeditor/codemirror-yaml/mode';\nimport {FontFamily} from './styles';\n\n// Explicitly register YAML to ensure that the YAML import is bundled correctly.\nregisterYaml();\n\nexport const DagitCodeMirrorStyle = createGlobalStyle`\n  .react-codemirror2 .CodeMirror {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n\n    /* Note: Theme overrides */\n    &.cm-s-default .cm-comment {\n      color: #999;\n    }\n  }\n\n  .CodeMirror-gutter-elt {\n    .CodeMirror-lint-marker-error {\n      background-image: none;\n      background: ${Colors.Red500};\n      mask-image: url(${Icons.error});\n      mask-size: cover;\n      margin-bottom: 2px;\n    }\n  }\n\n  .CodeMirror-hint,\n  .CodeMirror-lint-marker-error,\n  .CodeMirror-lint-marker-warning,\n  .CodeMirror-lint-message-error,\n  .CodeMirror-lint-message-warning {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n  }\n\n  .react-codemirror2 .CodeMirror.cm-s-dagit {\n    .cm-atom {\n      color: ${Colors.Blue700};\n    }\n\n    .cm-comment {\n      color: ${Colors.Gray400};\n    }\n\n    .cm-meta {\n      color: ${Colors.Gray700};\n    }\n\n    .cm-number {\n      color: ${Colors.Red700};\n    }\n\n    .cm-string {\n      color: ${Colors.Green700};\n    }\n\n    .cm-string-2 {\n      color: ${Colors.Olive700};\n    }\n\n    .cm-variable-2 {\n      color: ${Colors.Blue500};\n    }\n\n    .cm-keyword {\n      color: ${Colors.Yellow700};\n    }\n\n    .CodeMirror-selected {\n      background-color: ${Colors.Blue50};\n    }\n\n    .CodeMirror-gutters {\n      background-color: ${Colors.Gray50};\n    }\n\n    .cm-indent {\n      display: inline-block;\n\n      &.cm-zero {\n        box-shadow: -1px 0 0 ${Colors.Green200};\n      }\n\n      &.cm-one {\n        box-shadow: -1px 0 0 ${Colors.Blue100};\n      }\n\n      &.cm-two {\n        box-shadow: -1px 0 0 ${Colors.LightPurple};\n      }\n\n      &.cm-three {\n        box-shadow: -1px 0 0 ${Colors.Red200};\n      }\n\n      &.cm-four {\n        box-shadow: -1px 0 0 ${Colors.Yellow200};\n      }\n\n      &.cm-five {\n        box-shadow: -1px 0 0 ${Colors.Olive200};\n      }\n\n      &.cm-six {\n        box-shadow: -1px 0 0 ${Colors.Gray300};\n      }\n    }\n  }\n\n  div.CodeMirror-lint-tooltip {\n    background: rgba(255, 247, 231, 1);\n    border: 1px solid ${Colors.Gray200};\n  }\n\n  .CodeMirror-lint-message {\n    background: transparent;\n  }\n  .CodeMirror-lint-message.CodeMirror-lint-message-error {\n    background: transparent;\n  }\n\n  /* Ensure that hints aren't vertically cutoff*/\n  .CodeMirror-hint div {\n    max-height: none !important;\n  }\n`;\n\ninterface ThemeProp {\n  theme?: string[];\n}\n\nconst makeThemeString = (theme: string[] = []) => [...theme, 'dagit'].join(' ');\n\nexport const StyledReadOnlyCodeMirror = (\n  props: React.ComponentProps<typeof Uncontrolled> & ThemeProp,\n) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Uncontrolled\n        {...rest}\n        options={{...options, readOnly: true, theme: makeThemeString(theme)}}\n      />\n    </>\n  );\n};\n\nexport const StyledCodeMirror = (props: React.ComponentProps<typeof Controlled> & ThemeProp) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Controlled {...rest} options={{...options, theme: makeThemeString(theme)}} />\n    </>\n  );\n};\n","import * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {IconName} from './Icon';\n\ninterface Props {\n  title: React.ReactNode;\n  tags?: React.ReactNode;\n  icon?: IconName;\n  description?: React.ReactNode;\n  metadata?: React.ReactNode;\n  right?: React.ReactNode;\n  tabs?: React.ReactNode;\n}\n\nexport const PageHeader = (props: Props) => {\n  const {title, tags, right, tabs} = props;\n  return (\n    <PageHeaderContainer\n      background={Colors.Gray50}\n      padding={{top: 16, left: 24, right: 12}}\n      border={{side: 'bottom', width: 1, color: Colors.KeylineGray}}\n    >\n      <Box flex={{direction: 'row', justifyContent: 'space-between'}} padding={{bottom: 16}}>\n        <Box flex={{direction: 'row', alignItems: 'flex-start', gap: 12, wrap: 'wrap'}}>\n          {title}\n          {tags}\n        </Box>\n        {right}\n      </Box>\n      {tabs}\n    </PageHeaderContainer>\n  );\n};\n\nconst PageHeaderContainer = styled(Box)`\n  width: 100%;\n\n  /**\n   * Blueprint breadcrumbs annoyingly have a built-in height.\n   */\n  .bp3-breadcrumbs {\n    height: auto;\n  }\n`;\n","import * as React from 'react';\nimport styled, {css} from 'styled-components/macro';\n\nimport {Colors} from './Colors';\nimport {IconWrapper} from './Icon';\nimport {FontFamily} from './styles';\n\nexport interface TabStyleProps {\n  disabled?: boolean;\n  selected?: boolean;\n  count?: number | 'indeterminate' | null;\n  icon?: React.ReactNode;\n  title?: React.ReactNode;\n  $size?: 'small' | 'large';\n}\n\nexport const getTabA11yProps = (props: {selected?: boolean; disabled?: boolean}) => {\n  const {selected, disabled} = props;\n  return {\n    role: 'tab',\n    tabIndex: disabled ? -1 : 0,\n    'aria-disabled': disabled,\n    'aria-expanded': selected,\n    'aria-selected': selected,\n  };\n};\n\nexport const getTabContent = (props: TabStyleProps & {title?: React.ReactNode}) => {\n  const {title, count, icon} = props;\n  return (\n    <>\n      {title}\n      {icon}\n      {count !== undefined ? <Count>{count === 'indeterminate' ? '–' : count}</Count> : null}\n    </>\n  );\n};\n\nconst Count = styled.div`\n  display: inline;\n  font-family: ${FontFamily.monospace};\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: -0.02%;\n  padding: 0 4px;\n  color: ${Colors.Gray900};\n  background: ${Colors.Gray100};\n`;\n\nexport const tabCSS = css<TabStyleProps>`\n  background: none;\n  border: none;\n  font-size: 14px;\n  line-height: 20px;\n  font-weight: 600;\n  padding: ${({$size}) => ($size === 'small' ? '10px 0' : '16px 0')};\n  box-shadow: ${({selected}) => (selected ? Colors.Blue500 : 'transparent')} 0 -2px 0 inset;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  gap: 6px;\n\n  &,\n  & a {\n    cursor: pointer;\n    user-select: none;\n    color: ${({selected, disabled}) =>\n      selected ? Colors.Blue500 : disabled ? Colors.Gray300 : Colors.Gray700};\n  }\n\n  & ${IconWrapper} {\n    color: ${({selected, disabled}) =>\n      selected ? Colors.Blue500 : disabled ? Colors.Gray300 : ''};\n  }\n\n  /* Focus outline only when using keyboard, not when focusing via mouse. */\n  &:focus {\n    outline: none !important;\n    box-shadow: ${({selected, disabled}) =>\n        selected ? Colors.Blue500 : disabled ? 'transparent' : Colors.Blue200}\n      0 -2px 0 inset;\n  }\n\n  &:hover {\n    &,\n    a {\n      text-decoration: none;\n      color: ${({selected, disabled}) =>\n        selected ? Colors.Blue700 : disabled ? Colors.Gray300 : Colors.Blue700};\n    }\n    ${IconWrapper} {\n      color: ${({selected, disabled}) =>\n        selected ? Colors.Blue700 : disabled ? Colors.Gray300 : ''};\n    }\n  }\n`;\n\ninterface TabProps extends TabStyleProps, Omit<React.ComponentPropsWithoutRef<'button'>, 'title'> {}\n\nexport const Tab = styled((props: TabProps) => {\n  const containerProps = getTabA11yProps(props);\n  const content = getTabContent(props);\n\n  const titleText = typeof props.title === 'string' ? props.title : undefined;\n\n  return (\n    <button {...props} {...containerProps} title={titleText} type=\"button\">\n      {content}\n    </button>\n  );\n})<TabStyleProps>`\n  ${tabCSS}\n`;\n\ninterface TabsProps {\n  children: Array<React.ReactElement<TabProps>>;\n  selectedTabId?: string;\n  onChange?: (selectedTabId: string) => void;\n  size?: 'small' | 'large';\n}\n\nexport const Tabs = styled(({selectedTabId, children, onChange, size = 'large', ...rest}) => {\n  return (\n    <div {...rest} role=\"tablist\">\n      {React.Children.map(children, (child) =>\n        child\n          ? React.cloneElement(child, {\n              selected: child.props.selected || child.props.id === selectedTabId,\n              $size: size,\n              ...(onChange\n                ? {\n                    onClick: () => onChange(child.props.id),\n                  }\n                : {}),\n            })\n          : null,\n      )}\n    </div>\n  );\n})<TabsProps>`\n  display: flex;\n  gap: 16px;\n  font-size: ${({size}) => (size === 'small' ? '12px' : '14px')};\n  line-height: ${({size}) => (size === 'small' ? '16px' : '20px')};\n  font-weight: 600;\n`;\n","import * as CodeMirror from 'codemirror';\nimport 'codemirror/addon/hint/show-hint';\nimport 'codemirror/addon/search/search';\nimport 'codemirror/addon/search/searchcursor';\nimport 'codemirror/addon/dialog/dialog';\nimport 'codemirror/addon/dialog/dialog.css';\nimport * as yaml from 'yaml';\n\nimport {\n  ConfigSchema,\n  ConfigSchema_allConfigTypes_CompositeConfigType as CompositeConfigType,\n  ConfigSchema_allConfigTypes_MapConfigType as MapConfigType,\n} from '../types/ConfigSchema';\n\n// Example YAML for testing this parser:\n// https://gist.github.com/bengotow/0b700e7d0367750cb31eaf697f865d70\n\ninterface IParseStateParent {\n  key: string;\n  indent: number;\n  childKeys: string[];\n}\n\nenum ContainerType {\n  Dict = 'dict',\n  List = 'list',\n}\n\ninterface IParseState {\n  trailingSpace: boolean;\n  inlineContainers: ContainerType[];\n  escaped: boolean;\n  inValue: boolean;\n  inBlockLiteral: boolean;\n  inBlockLiteralIndentation: number;\n  parents: IParseStateParent[];\n}\n\n// Helper methods that mutate parser state. These must return new JavaScript objects.\n//\nfunction parentsPoppingItemsDeeperThan(parents: IParseStateParent[], indent: number) {\n  while (parents.length > 0 && parents[parents.length - 1]!.indent >= indent) {\n    parents = parents.slice(0, parents.length - 1);\n  }\n  return parents;\n}\n\nfunction parentsAddingChildKeyToLast(parents: IParseStateParent[], key: string) {\n  if (parents.length === 0) {\n    return [];\n  }\n\n  const immediateParent = parents[parents.length - 1]!;\n  return [\n    ...parents.slice(0, parents.length - 1),\n    {\n      key: immediateParent.key,\n      indent: immediateParent.indent,\n      childKeys: [...immediateParent.childKeys, key],\n    },\n  ];\n}\n\nconst indentMark = (col: number) => {\n  switch (col % 14) {\n    case 0:\n      return 'zero';\n    case 2:\n      return 'one';\n    case 4:\n      return 'two';\n    case 6:\n      return 'three';\n    case 8:\n      return 'four';\n    case 10:\n      return 'five';\n    case 12:\n      return 'six';\n    default:\n      return '';\n  }\n};\n\nfunction parentsAddingChildKeyAtIndent(parents: IParseStateParent[], key: string, indent: number) {\n  parents = parentsPoppingItemsDeeperThan(parents, indent);\n  parents = parentsAddingChildKeyToLast(parents, key);\n  parents = [...parents, {key, indent, childKeys: []}];\n  return parents;\n}\n\nconst Constants = ['true', 'false', 'on', 'off', 'yes', 'no'];\n\nexport const RegExps = {\n  KEYWORD: new RegExp('\\\\b((' + Constants.join(')|(') + '))$', 'i'),\n  DICT_COLON: /^:\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  DICT_KEY: /^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^# ,]*?(?=\\s*:)/,\n  // eslint-disable-next-line no-useless-escape\n  QUOTED_STRING: /^('([^']|\\\\.)*'?|\"([^\"\\\\]|\\\\.)*\"?)/,\n  // eslint-disable-next-line no-useless-escape\n  BLOCKSTART_PIPE_OR_ARROW: /^\\s*(\\||\\>)\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  NUMBER: /^\\s*-?[0-9\\.]+(?![0-9\\.]+)$/,\n  // eslint-disable-next-line no-useless-escape\n  VARIABLE: /^\\s*(\\&|\\*)[a-z0-9\\._-]+$/i,\n};\n\nconst defineYamlMode = () => {\n  CodeMirror.defineMode('yaml', () => {\n    console.log('HEY');\n    return {\n      lineComment: '#',\n      flattenSpans: false,\n      fold: 'indent',\n      startState: (): IParseState => {\n        return {\n          trailingSpace: false,\n          escaped: false,\n          inValue: false,\n          inBlockLiteral: false,\n          inBlockLiteralIndentation: 0,\n          inlineContainers: [],\n          parents: [],\n        };\n      },\n      token: (stream, state: IParseState) => {\n        const ch = stream.peek();\n        const col = stream.column();\n\n        // reset escape, indent and trailing\n        const wasEscaped = state.escaped;\n        const wasTrailingSpace = state.trailingSpace;\n        state.escaped = false;\n        state.trailingSpace = false;\n\n        // indent\n        if (col % 2 === 0 && ch === ' ' && stream.match(/  /)) {\n          state.trailingSpace = true;\n          return `indent ${indentMark(col)}`;\n        }\n\n        // whitespace\n        const trailingSpace = stream.eatSpace();\n        if (trailingSpace) {\n          state.trailingSpace = true;\n        }\n\n        // escape\n        if (ch === '\\\\') {\n          state.escaped = true;\n          stream.next();\n          return null;\n        }\n\n        // comments\n        // either beginning of the line or had whitespace before\n        if (ch === '#' && (stream.sol() || wasTrailingSpace)) {\n          stream.skipToEnd();\n          return 'comment';\n        }\n\n        if (state.inBlockLiteral) {\n          // continuation of a literal string that was started on a previous line\n          if (stream.indentation() > state.inBlockLiteralIndentation) {\n            stream.skipToEnd();\n            return 'string';\n          }\n          state.inBlockLiteralIndentation = 0;\n          state.inBlockLiteral = false;\n        }\n\n        // array list item, value to follow\n        if (stream.match(/-/)) {\n          state.inValue = true;\n          return 'meta';\n        }\n\n        // doc start / end\n        if (stream.sol()) {\n          state.inValue = false;\n          state.parents = [];\n\n          if (stream.match(/---/) || stream.match(/\\.\\.\\./)) {\n            return 'def';\n          }\n        }\n\n        // Handle inline objects and arrays. These can be nested arbitrarily but we\n        // don't currently support them spanning multiple lines.\n        if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n          if (ch === '{') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.Dict];\n            state.inValue = false;\n          } else if (ch === '}') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = state.inlineContainers.length > 0;\n          } else if (ch === '[') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.List];\n            state.inValue = true;\n          } else if (ch === ']') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.inValue = state.inlineContainers.length > 0;\n          }\n          state.trailingSpace = false;\n          return 'meta';\n        }\n\n        // Handle inline separators. For dictionaries, we pop from value parsing state back to\n        // key parsing state after a comma and unwind the parent stack.\n        if (state.inlineContainers && !wasEscaped && ch === ',') {\n          const current = state.inlineContainers[state.inlineContainers.length - 1];\n          if (current === ContainerType.Dict) {\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = false;\n          }\n          stream.next();\n          return 'meta';\n        }\n\n        // A `:` fragment starts value parsing mode if it is not the last character on the line\n        if (stream.match(RegExps.DICT_COLON)) {\n          state.inValue = !stream.eol();\n          return 'meta';\n        }\n\n        // Handle dict key fragments. May be the first element on a line or nested within an inline\n        // (eg: {a: 1, b: 2}). We add the new key to the current `parent` and push a new parent\n        // in case the dict key has subkeys.\n        if (!state.inValue) {\n          const match = stream.match(RegExps.DICT_KEY);\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            return 'atom';\n          }\n        }\n\n        if (state.inValue) {\n          let result = null;\n\n          // Child dicts can start within a value if the user is creating a list, but we don't want to\n          // clasifiy \"my\" as a sub-dict in \"- my:weird:key\". As a balance we require that the colon\n          // be followed by the end-of-line or whitespace.\n          const match = !stream.string.match(/[^\\s]:[^\\s]/)\n            ? stream.match(RegExps.DICT_KEY)\n            : false;\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.inValue = false;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            result = 'atom';\n          }\n\n          if (stream.match(RegExps.BLOCKSTART_PIPE_OR_ARROW)) {\n            state.inBlockLiteralIndentation = stream.indentation();\n            state.inBlockLiteral = true;\n            result = 'meta';\n          }\n\n          if (!result) {\n            // First, read any value that is a quoted string until we reach the end quote.\n            let match = stream.match(RegExps.QUOTED_STRING);\n            if (!match) {\n              // If the value is not a string in quotes, read until a separator (,) or container closing character,\n              // then we'll decide what to do with it.\n              const parentContainer = state.inlineContainers[state.inlineContainers.length - 1];\n              match =\n                parentContainer === ContainerType.List\n                  ? stream.match(/^[^,\\]]+/)\n                  : parentContainer === ContainerType.Dict\n                  ? stream.match(/^[^,\\}]+/)\n                  : stream.match(/^.+$/);\n            }\n            const value = match ? match[0]! : '';\n            if (value.match(RegExps.VARIABLE)) {\n              result = 'variable-2';\n            } else if (value.match(RegExps.NUMBER)) {\n              result = 'number';\n            } else if (value.match(RegExps.KEYWORD)) {\n              result = 'keyword';\n            } else {\n              // \"In YAML, you can write a string without quotes, if it doesn't have a special meaning.\",\n              // so if we can't match the content to any other type and we are inValue, we make it a string.\n              // http://blogs.perl.org/users/tinita/2018/03/strings-in-yaml---to-quote-or-not-to-quote.html\n              result = 'string';\n            }\n          }\n\n          // If after consuming the value and trailing spaces we're at the end of the\n          // line, terminate the value and look for another key on the following line.\n          if (stream.eol() && !state.inBlockLiteral) {\n            state.inValue = false;\n          }\n\n          return result;\n        }\n\n        stream.skipToEnd();\n\n        return null;\n      },\n    };\n  });\n};\n\n// TODO\n// Uniquity of keys\n// add colon\n// add colon and return for composites\n\ntype CodemirrorLocation = {\n  line: number;\n  ch: number;\n};\n\ntype CodemirrorHint = {\n  render: (el: Element, self: any, data: any) => void;\n  text: string;\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\ntype CodemirrorToken = CodeMirror.Token & {\n  state: IParseState;\n};\n\nconst registerYamlHint = () => {\n  CodeMirror.registerHelper(\n    'hint',\n    'yaml',\n    (\n      editor: any,\n      options: {\n        schema?: ConfigSchema;\n      },\n    ): {list: Array<CodemirrorHint>; from: CodemirrorLocation; to: CodemirrorLocation} => {\n      const {\n        cursor,\n        context,\n        token,\n        start,\n        searchString,\n        prevToken,\n      } = expandAutocompletionContextAtCursor(editor);\n\n      const from = {line: cursor.line, ch: start};\n      const to = {line: cursor.line, ch: token.end};\n\n      if (!options.schema) {\n        return {list: [], from, to};\n      }\n\n      if (!context) {\n        return {list: [], from, to};\n      }\n\n      // Since writing meaningful tests for this functionality is difficult given a) no jsdom\n      // support for APIs that codemirror uses (and so no way to use snapshot tests) and b) no\n      // appetite (yet) for writing Selenium tests, we record here the manual tests used to verify\n      // this logic. In what follows, | represents the position of the cursor and -> the transition\n      // on accepting an autocomplete suggestion for `storage: filesystem:\n\n      // st|\n      // ->\n      // storage:\n      //   |\n\n      // storage:|\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage: |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:  |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:\n      //   |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      const isCompOrList = (key: string): boolean => {\n        if (!options.schema) {\n          return false;\n        }\n        // Using a lookup table here seems like a good idea\n        // https://github.com/dagster-io/dagster/issues/1966\n        let type = options.schema.allConfigTypes.find((t) => t.key === key);\n        if (!type) {\n          return false;\n        }\n\n        // If nullable, extract the inner type.\n        if (type.__typename === 'NullableConfigType') {\n          const innerKey = type.typeParamKeys[0];\n          type = options.schema.allConfigTypes.find((t) => t.key === innerKey);\n          if (!type) {\n            return false;\n          }\n        }\n\n        return (\n          type.__typename === 'ArrayConfigType' ||\n          type.__typename === 'CompositeConfigType' ||\n          type.__typename === 'MapConfigType'\n        );\n      };\n\n      const formatReplacement = (\n        field: any,\n        start: any,\n        token: CodemirrorToken,\n        prevToken: CodemirrorToken,\n        inList: boolean,\n      ) => {\n        let replacement = `${field.name}`;\n        let postReplacementIndentation = start;\n\n        const listMarkerPresent = prevToken.string === ' ' || prevToken.string === '-';\n        if (inList && !listMarkerPresent) {\n          replacement = `- ${replacement}`;\n          postReplacementIndentation += 2;\n        }\n\n        const cursorAtColon = token.string.startsWith(':');\n        if (cursorAtColon) {\n          const nextLineIndent = prevToken.start + 2;\n          replacement = `\\n${' '.repeat(nextLineIndent)}${replacement}`;\n          postReplacementIndentation = nextLineIndent;\n        }\n\n        const completionHasChildren = isCompOrList(field.configTypeKey);\n        if (completionHasChildren) {\n          replacement += `:\\n${' '.repeat(postReplacementIndentation + 2)}`;\n        } else {\n          replacement += ': ';\n        }\n\n        return replacement;\n      };\n\n      const buildSuggestion = (\n        display: string,\n        replacement: string,\n        description: string | null,\n      ): CodemirrorHint => ({\n        text: replacement,\n        render: (el) => {\n          const div = document.createElement('div');\n          div.textContent = display;\n          if (description) {\n            const docs = document.createElement('div');\n            docs.innerText =\n              description.length < 90 ? description : description.substr(0, 87) + '...';\n            docs.style.opacity = '0.5';\n            docs.style.overflow = 'hidden';\n            docs.style.maxHeight = '33px';\n            docs.style.maxWidth = '360px';\n            docs.style.whiteSpace = 'normal';\n            div.appendChild(docs);\n          }\n          el.appendChild(div);\n        },\n        from,\n        to,\n      });\n\n      // Calculate if this is on a new-line child of a scalar union type, as an indication that we\n      // should autocomplete the selector fields of the scalar union\n      const isScalarUnionNewLine =\n        context.type.__typename === 'ScalarUnionConfigType' && !prevToken.end;\n\n      // The context will have available fields if the type is a composite config type OR a scalar\n      // union type\n      if (\n        context.availableFields.length &&\n        (context.type.__typename === 'CompositeConfigType' || isScalarUnionNewLine)\n      ) {\n        return {\n          list: context.availableFields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, context.inArray),\n                field.description,\n              ),\n            ),\n          from,\n          to,\n        };\n      }\n\n      // Completion of enum field values\n      if (context.type.__typename === 'EnumConfigType') {\n        const searchWithoutQuotes = searchString.startsWith('\"')\n          ? searchString.substr(1)\n          : searchString;\n        return {\n          list: context.type.values\n            .filter((val) => val.value.startsWith(searchWithoutQuotes))\n            .map((val) => buildSuggestion(val.value, `\"${val.value}\"`, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of boolean field values\n      if (context.type.__typename === 'RegularConfigType' && context.type.givenName === 'Bool') {\n        return {\n          list: ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of Scalar Union field values, the union of the scalar suggestions and the\n      // non-scalar suggestions\n      const type = context.type;\n      if (type.__typename === 'ScalarUnionConfigType') {\n        const scalarType = options.schema.allConfigTypes.find((x) => x.key === type.scalarTypeKey);\n        const nonScalarType = options.schema.allConfigTypes.find(\n          (x) => x.key === type.nonScalarTypeKey,\n        );\n        let scalarSuggestions: CodemirrorHint[] = [];\n        if (\n          scalarType &&\n          scalarType.__typename === 'RegularConfigType' &&\n          scalarType.givenName === 'Bool'\n        ) {\n          scalarSuggestions = ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null));\n        }\n        let nonScalarSuggestions: CodemirrorHint[] = [];\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          nonScalarSuggestions = nonScalarType.fields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, false),\n                field.description,\n              ),\n            );\n        }\n\n        return {list: [...scalarSuggestions, ...nonScalarSuggestions], from, to};\n      }\n\n      return {list: [], from, to};\n    },\n  );\n};\n\n/** Takes the pipeline schema and the YAML tokenizer state and returns the\n * type in scope and available (yet-to-be-used) fields\n * if it is a composite type.\n */\nfunction findAutocompletionContext(\n  schema: ConfigSchema | null,\n  parents: IParseStateParent[],\n  currentIndent: number,\n) {\n  parents = parents.filter(({indent}) => currentIndent > indent);\n  const immediateParent = parents[parents.length - 1];\n\n  if (!schema) {\n    // Schema may still be loading\n    return;\n  }\n\n  // We only provide autocompletion if the root type is a Map or a composite (Shape)\n  let type = schema.allConfigTypes.find((t) => t.key === schema.rootConfigType.key);\n  if (!type || (type.__typename !== 'CompositeConfigType' && type.__typename !== 'MapConfigType')) {\n    return null;\n  }\n\n  let available = type.__typename === 'CompositeConfigType' ? type.fields : [];\n\n  // Tracks the nearest mapping type (Shape, Map, etc.) in the hierarchy to the cursor\n  // This is what's rendered in the schema sidebar\n  let closestMappingType: MapConfigType | CompositeConfigType = type;\n  let inArray = false;\n\n  // Tracks the type key to be used for the next depth level\n  // Used for Map config types, which specify the type key for their values, otherwise is null\n  let nextTypeKey: string | null =\n    type.__typename === 'MapConfigType' ? type.typeParamKeys[1]! : null;\n\n  if ((available || type.__typename === 'MapConfigType') && parents.length > 0) {\n    for (const parent of parents) {\n      // In order to provide completion, we must either have type information on hand (parentTypeDef)\n      // for the current key that we are in, or we must have the type info provided by an enclosing Map (nextTypeKey)\n      const parentTypeDef = available.find(({name}) => parent.key === name);\n      if (!parentTypeDef && !nextTypeKey) {\n        return null;\n      }\n\n      // The current composite type's available \"fields\" each only have a configType key.\n      // The rest of the configType's information is in the top level schema.allConfigTypes\n      // to avoid superlinear GraphQL response size.\n      const typeKey = nextTypeKey ? nextTypeKey : parentTypeDef?.configTypeKey;\n      nextTypeKey = null;\n\n      let parentConfigType = schema.allConfigTypes.find((t) => t.key === typeKey)!;\n\n      // If nullable, extract the inner type.\n      if (parentConfigType.__typename === 'NullableConfigType') {\n        const innerType = parentConfigType.typeParamKeys[0];\n        parentConfigType = schema.allConfigTypes.find((t) => t.key === innerType)!;\n      }\n\n      let childTypeKey = parentConfigType.key;\n      let childEntriesUnique = true;\n\n      inArray = parentConfigType.__typename === 'ArrayConfigType';\n      if (inArray) {\n        childTypeKey = parentConfigType.typeParamKeys[0]!;\n        childEntriesUnique = false;\n      }\n\n      // Maps provide no direct autocompletions, but they do act as the closestMappingType,\n      // meaning they show up in the schema sidebar\n      if (parentConfigType.__typename === 'MapConfigType') {\n        nextTypeKey = parentConfigType.typeParamKeys[1]!;\n        closestMappingType = parentConfigType;\n        available = [];\n        continue;\n      }\n\n      type = schema.allConfigTypes.find((t) => t.key === childTypeKey);\n      if (!type) {\n        return null;\n      }\n\n      if (type.__typename === 'ScalarUnionConfigType') {\n        available = [];\n        const nonScalarTypeKey = type.nonScalarTypeKey;\n        const nonScalarType = schema.allConfigTypes.find((x) => x.key === nonScalarTypeKey);\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          available = nonScalarType.fields;\n        }\n      } else if (type.__typename === 'CompositeConfigType') {\n        closestMappingType = type;\n        available = type.fields;\n\n        if (parent === immediateParent && childEntriesUnique) {\n          available = available.filter(\n            (item) => immediateParent.childKeys.indexOf(item.name) === -1,\n          );\n        }\n      } else {\n        available = [];\n      }\n    }\n  }\n\n  return {type, closestMappingType, availableFields: available, inArray};\n}\n\n// Find context for a fully- or partially- typed key or value in the YAML document\nexport function expandAutocompletionContextAtCursor(editor: any) {\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  const cursor = editor.getCursor();\n  const token: CodemirrorToken = editor.getTokenAt(cursor);\n  const prevToken: CodemirrorToken = editor.getTokenAt({\n    line: cursor.line,\n    ch: token.start,\n  });\n\n  let searchString: string;\n  let start: number;\n  if (token.type === 'whitespace' || token.string.startsWith(':')) {\n    searchString = '';\n    start = token.end;\n  } else {\n    searchString = token.string;\n    start = token.start;\n  }\n\n  // Takes the schema and the YAML tokenizer state and returns the\n  // type in scope and available (yet-to-be-used) fields\n  // if it is a composite type.\n  return {\n    start,\n    cursor,\n    searchString,\n    token,\n    prevToken,\n    context: findAutocompletionContext(schema, token.state.parents, start),\n  };\n}\n\ntype CodemirrorLintError = {\n  message: string;\n  severity: 'error' | 'warning' | 'information' | 'hint';\n  type: 'validation' | 'syntax' | 'deprecation';\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\nexport type YamlModeValidationResult =\n  | {\n      isValid: true;\n    }\n  | {\n      isValid: false;\n      errors: YamlModeValidationError[];\n    };\n\nexport type YamlModeValidateFunction = (configYaml: string) => Promise<YamlModeValidationResult>;\n\nexport type YamlModeValidationError = {\n  message: string;\n  path: string[];\n  reason: string;\n};\n\nCodeMirror.registerHelper('dagster-docs', 'yaml', (editor: any, pos: CodeMirror.Position) => {\n  const token = editor.getTokenAt(pos);\n\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  if (token.type !== 'atom') {\n    return null;\n  }\n\n  const context = findAutocompletionContext(schema, token.state.parents, token.start);\n  const match =\n    context &&\n    context.type.__typename === 'CompositeConfigType' &&\n    context.type.fields.find((f) => f.name === token.string);\n\n  if (match && match.description) {\n    return match.description;\n  }\n\n  return null;\n});\n\nconst registerYamlLint = () => {\n  CodeMirror.registerHelper(\n    'lint',\n    'yaml',\n    async (\n      text: string,\n      {checkConfig}: {checkConfig: YamlModeValidateFunction},\n      editor: any,\n    ): Promise<Array<CodemirrorLintError>> => {\n      const codeMirrorDoc = editor.getDoc();\n\n      // TODO: In some scenarios where every line yields an error `parseDocument` can take 1s+\n      // and returns 20,000+ errors. The library does not have a \"bail out\" option but we need one.\n      // However we can't switch libraries because we need the structured document model this returns.\n      // (It's not just text parsed to plain JS objects.)\n      const yamlDoc = yaml.parseDocument(text);\n      const lints: Array<CodemirrorLintError> = [];\n      const lintingTruncated = yamlDoc.errors.length > 10;\n      let lastMarkLocation: CodeMirror.Position | undefined;\n\n      yamlDoc.errors.slice(0, 10).forEach((error) => {\n        const [fromPos, toPos] = error.pos;\n        const from = codeMirrorDoc.posFromIndex(fromPos) as CodeMirror.Position;\n        const to = codeMirrorDoc.posFromIndex(toPos) as CodeMirror.Position;\n\n        if (!lastMarkLocation || lastMarkLocation.line < from.line) {\n          lastMarkLocation = from;\n        }\n\n        lints.push({\n          message: error.message,\n          severity: 'error',\n          type: 'syntax',\n          from,\n          to,\n        });\n      });\n\n      if (lintingTruncated && lastMarkLocation) {\n        const nextLineLocation: CodeMirror.Position = {\n          line: lastMarkLocation.line + 1,\n          ch: 0,\n        };\n        lints.push({\n          message: `${yamlDoc.errors.length - lints.length} more errors - bailed out.`,\n          severity: 'warning',\n          type: 'syntax',\n          from: nextLineLocation,\n          to: nextLineLocation,\n        });\n      }\n\n      if (yamlDoc.errors.length === 0) {\n        const validationResult = await checkConfig(text);\n        if (!validationResult.isValid) {\n          validationResult.errors.forEach((error) => {\n            const lint = validationErrorToCodemirrorError(error, yamlDoc, codeMirrorDoc);\n            if (lint) {\n              lints.push(lint);\n            }\n          });\n        }\n      }\n\n      return lints;\n    },\n  );\n};\n\nexport function validationErrorToCodemirrorError(\n  error: YamlModeValidationError,\n  yamlDoc: yaml.Document,\n  codeMirrorDoc: any,\n): CodemirrorLintError | null {\n  const part = error.reason === 'RUNTIME_TYPE_MISMATCH' ? 'value' : 'key';\n  const range = findRangeInDocumentFromPath(yamlDoc, error.path, part);\n  if (range === null) {\n    return null;\n  }\n  return {\n    message: error.message,\n    severity: 'error',\n    type: 'syntax',\n    from: codeMirrorDoc.posFromIndex(range ? range.start : 0) as CodeMirror.Position,\n    to: codeMirrorDoc.posFromIndex(\n      range ? range.end : Number.MAX_SAFE_INTEGER,\n    ) as CodeMirror.Position,\n  };\n}\n\nexport function findRangeInDocumentFromPath(\n  doc: yaml.Document,\n  path: Array<string>,\n  pathPart: 'key' | 'value',\n): {start: number; end: number} | null {\n  let node = nodeAtPath(doc, path);\n  if (!node || !('type' in node)) {\n    return null;\n  }\n\n  if (node.type === 'PAIR') {\n    if (pathPart === 'value' && node.value) {\n      node = node.value;\n    } else {\n      node = node.key;\n    }\n  }\n\n  if (node && node.range) {\n    return {\n      start: node.range[0],\n      end: node.range[1],\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction nodeAtPath(doc: yaml.Document, path: Array<string>) {\n  let node: any = doc.contents;\n  for (let i = 0; i < path.length; i++) {\n    const part = path[i]!;\n    if (node && node.type && node.type === 'PAIR') {\n      node = node.value;\n    }\n\n    if (node && node.type && (node.type === 'SEQ' || node.type === 'FLOW_SEQ')) {\n      const index = Number.parseInt(part);\n      if (!Number.isNaN(index)) {\n        node = node.items[index];\n      } else {\n        return null;\n      }\n    } else if (node && node.type && (node.type === 'FLOW_MAP' || node.type === 'MAP')) {\n      const item = node.items.find(({key}: {key: any}) => key.value === part);\n      if (item && item.type && item.type === 'PAIR') {\n        node = item;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return node;\n}\n\nexport const registerYaml = () => {\n  defineYamlMode();\n  registerYamlHint();\n  registerYamlLint();\n};\n"],"names":["registerYaml","DagitCodeMirrorStyle","createGlobalStyle","FontFamily","Colors","Icons","makeThemeString","theme","join","StyledReadOnlyCodeMirror","props","options","rest","readOnly","StyledCodeMirror","PageHeader","title","tags","right","tabs","PageHeaderContainer","background","padding","top","left","border","side","width","color","flex","direction","justifyContent","bottom","alignItems","gap","wrap","styled","Box","getTabA11yProps","selected","disabled","role","tabIndex","getTabContent","count","icon","undefined","Count","tabCSS","css","$size","IconWrapper","Tab","containerProps","content","titleText","type","Tabs","selectedTabId","children","onChange","size","React","child","id","onClick","ContainerType","parentsAddingChildKeyAtIndent","parents","key","indent","length","slice","parentsPoppingItemsDeeperThan","immediateParent","childKeys","parentsAddingChildKeyToLast","RegExps","KEYWORD","RegExp","DICT_COLON","DICT_KEY","QUOTED_STRING","BLOCKSTART_PIPE_OR_ARROW","NUMBER","VARIABLE","registerYamlHint","CodeMirror","editor","expandAutocompletionContextAtCursor","cursor","context","token","start","searchString","prevToken","from","line","ch","to","end","schema","list","formatReplacement","field","inList","replacement","name","postReplacementIndentation","listMarkerPresent","string","startsWith","nextLineIndent","repeat","completionHasChildren","allConfigTypes","find","t","__typename","innerKey","typeParamKeys","isCompOrList","configTypeKey","buildSuggestion","display","description","text","render","el","div","document","createElement","textContent","docs","innerText","substr","style","opacity","overflow","maxHeight","maxWidth","whiteSpace","appendChild","isScalarUnionNewLine","availableFields","filter","map","inArray","searchWithoutQuotes","values","val","value","givenName","scalarType","x","scalarTypeKey","nonScalarType","nonScalarTypeKey","scalarSuggestions","nonScalarSuggestions","fields","findAutocompletionContext","currentIndent","rootConfigType","available","closestMappingType","nextTypeKey","parent","parentTypeDef","typeKey","parentConfigType","innerType","childTypeKey","childEntriesUnique","item","indexOf","hintOptions","getCursor","getTokenAt","state","pos","match","f","validationErrorToCodemirrorError","error","yamlDoc","codeMirrorDoc","part","reason","range","findRangeInDocumentFromPath","path","message","severity","posFromIndex","Number","MAX_SAFE_INTEGER","doc","pathPart","node","contents","i","index","parseInt","isNaN","items","nodeAtPath","console","log","lineComment","flattenSpans","fold","startState","trailingSpace","escaped","inValue","inBlockLiteral","inBlockLiteralIndentation","inlineContainers","stream","peek","col","column","wasEscaped","wasTrailingSpace","indentMark","eatSpace","next","sol","skipToEnd","indentation","Dict","List","eol","keyIndent","result","parentContainer","checkConfig","getDoc","yaml","lints","lintingTruncated","errors","forEach","fromPos","toPos","lastMarkLocation","push","nextLineLocation","validationResult","isValid","lint"],"sourceRoot":""}